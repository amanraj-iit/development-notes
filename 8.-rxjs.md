# 8. RxJS

### Stream of Values

```javascript
// first example
document.addEventListener('click', evt => {
    console.log(evt);
});

// second example
let counter = 0;
setInterval(() => {
    console.log(counter);
}, 1000);

// third example
setTimeout(() => {
    console.log("finished");
}, 3000);
```

* First and second example are multivalued streams since they are never complete
* Third example completes after executing once

> If there are multiple nested reactive streams say in click we want timeout and then interval repeat. Nesting it means we need to handle closing too so RxJS \(Reactive extensions for Javascript\)

### Observable and Streams

Observable is definition subscribing to it becomes stream

```javascript
const interval$ = timer(3000, 1000);        // observable
interval$.subscribe(val => console.log("stream 1 -> " + val));        // stream
interval$.subscribe(val => console.log("stream 2 -> " + val));        // stream
```

Stream pattern

```javascript
const click$ = fromEvent(document, 'click');
click$.subscribe(
    evt => console.log(evt),            // called everytime
    err => console.log(err),
    () => console.log('completed!')
);
// after calling event it might either go to err, or completed or neither of them
// in case of timer it goes to neither err or ()
```

### Creating observable from scratch

```typescript
const http$ = Observable.create(observer => {
    fetch('/api/courses')
        .then(response => {
            return response.json();
        })
        .then(body => {
            observer.next(body);
            observer.complete();
        })
        .catch(err => {
            observer.error(err);
        })
});
```

> fetch gives a promise

The advantage of transforming promise to observable here is that we can use RxJs operators

### Map operator

![](.gitbook/assets/image%20%2863%29.png)

```typescript
export class HomeComponent implements OnInit {
    beginnerCourses$: Observable<Course[]>;
    advancedCourses$: Observable<Course[]>;
    
    ngOnInit() {
        const http$: Observable<Course[]> = createHttpObservable('/api/courses');
        const courses$ = http$.pipe(map(res => Object.values(res.payload)));
        this.beginnerCourses$ = courses$.pipe(
            map(courses => courses.filter(
                course => course.category === 'BEGINNER')
            )
        );
        this.advancedCourses$ = courses$.pipe(
            map(courses => courses.filter(
                course => course.category === 'ADVANCED')
            )
        );
    }
}
```

Simply use async pipe in template to get value in template, it will automatically unsubscribe when the template gets destroyed

**There's one problem, we are calling api twice** and both gives exactly same data

![](.gitbook/assets/image%20%2865%29.png)

### Share Replay and Tap operator

Refractoring above courses variable to

```typescript
const courses$ = http$.pipe(
    tap(() => console.log('HTTP request executed')),
    map(res => Object.values(res.payload)),
    shareReplay(),
);
```

tap is used whenever we are doing something outside of variables within observable  
Share replay shares the data with new subscribers of the observable so if we check again the api calls there will be only one hence this solves the above problem.

### Concat operator \(Sequence Strategy\)

![First observable completes then second starts and after it gets completed we want result](.gitbook/assets/image%20%2862%29.png)

> We can ofcourse concat more than 2 observables

```typescript
const source1$ = of(1, 2);
const source2$ = of(3);
const source3$ = of(4, 5);

const res$ = concat(source1$, source2$, source3$);
res$.subscribe(console.log);
// 1
// 2
// 3
// 4
// 5
```

If say one of source never gets completed then, other sources is never subscribed and the execution keeps going for that subscriber only

```typescript
const source1$ = interval(1000);
const source2$ = of(3);
const source3$ = of(4, 5);

const res$ = concat(source1$, source2$, source3$);
res$.subscribe(console.log);
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
```

### Switch Map and Filter Operator

Lets say we want to implement an auto save functionality for a form

```typescript
ngOnInit() {
    this.form.valueChanges.pipe(
        filter(() => this.form.valid)
    )
    .subscribe(changes => {
        const saveCourse$ = fromPromise(fetch(`/api/courses/${this.course.id}`, {
            method: 'PUT',
            body: JSON.stringify(changes),
            headers: {'content-type': 'application/json'}
        }));
        
        saveCourse$.subscribe();
    });
}
```

Above implementation have following issues:

* Nested subscribe is anti pattern should be avoided
* As we type something in form textfield with each input the api gets called and with waterfall diagram we can see it gets called at same time which we don't want we want it to get executed one after another because if thats not the case then we don't have guarantee that last saved value is the last valid saved entry in server.

![](.gitbook/assets/image%20%2861%29.png)

```typescript
ngOnInit() {
    this.form.valueChanges.pipe(
        filter(() => this.form.valid),
        concatMap(changes => this.saveCourse(changes))
    )
    .subscribe(console.log);
}

saveCourse(changes) {
    return fromPromise(fetch(`/api/courses/${this.course.id}`, {
        method: 'PUT',
        body: JSON.stringify(changes),
        headers: {'content-type': 'application/json'}
    }));
}
```

> Now the problem is since save operations are happening in sequence it can get overwhelmed and take a lot of time when there are lot of requests. Use debalance operator for that.

### Merge & MergeMap Operator \(Parallel Strategy\)

![](.gitbook/assets/image%20%2864%29.png)

Its ideal for running long running parallel observables and getting results combined

```typescript
const interval1$ = interval(1000);
const interval2$ = interval1$.pipe(map(val => 10 * val));
const result$ = merge(interval1$, interval2$);
result$.subscribe(console.log);
```

> Similar to concatMap there's also mergeMap for 2nd order merge handling

### ExhaustMap operator

Let's say we have a save button that will save the form data to server. If someone press the save button 10 times very quickly then it will overwhelm the server because it will send it in sequence and wait for all clicks save operation.

![5 is emitted while 3 is still running so it gets ignored and we only get 1 and 3 in 2nd order](.gitbook/assets/image%20%2859%29.png)

```typescript
fromEvent(this.saveButton.nativeElement, 'click').pipe(
    exhaustMap(() => this.saveCourse(this.form.value))
).subscribe(console.log);
```

### DebounceTime & DistinctUntilChanged Operator

We want to implement instant search query thing for that we don't want to keep sending requests for every change. DebounceTime waits until specified ms of time and picks the latest one within that window of time 

![](.gitbook/assets/image%20%2860%29.png)

```typescript
fromEvent<any>(this.input.nativeElement, 'keyup').pipe(
    map(event => event.target.value),
    debounceTime(400),
    distinctUntilChanged()
).subscribe(console.log);
```

